"""

# re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
语法： re.match(pattern, string, flags=0)
匹配成功后，我们可以使用.group([num]) 或 .groups() 匹配对象函数来获取匹配表达式。
# re.search 扫描整个字符串并返回第一个成功的匹配。
# re.findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。
# 字符串替换：re.sub(pattern, repl, string, count=0, flags=0)


# re.compile()生成的是正则对象，单独使用没有任何意义，需要和findall(), search(), match(）搭配使用
# re.search(pattern, string)的调用方式就转换为 pattern.search(string)的调用方式，多次调用一个正则表达式就重复利用这个正则对象，
# 可以实现更有效率的匹配


# 正则表达式修饰符 - 可选标志:
re.I	使匹配对大小写不敏感
re.L	做本地化识别（locale-aware）匹配
re.M	多行匹配，影响 ^ 和 $
re.S	使 . 匹配包括换行在内的所有字符
re.U	根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X	该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。


正则表达式模式:
标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。
通常在前面加上r,用来转义'\',(如r'\t'，等价于 \\t)
^	    匹配字符串的开头
$	    匹配字符串的末尾。
.	    匹配任意字符，除了换行符
[...]	用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
[^...]	不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
re*	    匹配0个或多个的re表达式。
re+	    匹配1个或多个的表达式。
re?	    匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
a|b	匹配a或b
(re)	匹配括号内的表达式，也表示一个组
re{n,m}	匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
(?imx)	正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
(?-imx)	正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?:re)	类似 (...), 但是不表示一个组
(?imx:re)	在括号中使用i, m, 或 x 可选标志
(?-imx:re)	在括号中不使用i, m, 或 x 可选标志
(?#...)	注释.
(?=re)	前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
(?!re)	前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。
(?>re)	匹配的独立模式，省去回溯。
\d	    匹配任意数字，等价于 [0-9]。
\D	    匹配任意非数字
\w	    匹配数字字母下划线
\W	    匹配非数字字母下划线
\s	    匹配任意空白字符，等价于 [\t\n\r\f]。
\S	    匹配任意非空字符
\A	    匹配字符串开始
\Z	    匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。
\z	    匹配字符串结束
\G	    匹配最后匹配完成的位置。
\b	    匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B	    匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\1...\9	匹配第n个分组的内容。

.*      表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符

# 正则表达式默认是'贪心'的,即匹配尽可能长的结果
在"*","?","+","{m,n}"后面加上?   表示"非贪婪"模式，只保存第一个匹配到的子串

[a-zA-Z0-9]	匹配任何字母及数字

"""